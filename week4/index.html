<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Week04 Notes</title>
    <meta name="description" content="Week04 Reading notes">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@300&display=swap" rel="stylesheet">
</head>
<body>
<!-- &lt; < -->
<!-- &gt; > -->
<!-- &emsp; four space tab -->

<h1>Week04 notes:</h1>

<h2>Chapter 8 Forums: </h2>
---------------------------------------------------------------------------------------------------<br><br>

Forms like cougarboard.com use the &lt;form&gt; element which gives control over the form for things such as fields menus and buttons.<br>
Once each form field has been populated that info can the be processed.<br>

The below example shows more or less a simple box for searching that would be similar to what google uses. an empty box with a button<br>
for submitting the request or user could press enter to submit as well<br><br>

&lt;!doctype html><br>
&lt;html lang='en'><br>
&lt;head><br>
&lt;meta charset='utf-8'><br>
&lt;title>Search&lt;/title><br>
&lt;/head><br>
&lt;body><br>
&lt;form name='search' action='/search'><br>
&emsp;&lt;input name='searchInput'><br>
&emsp;&lt;button type='submit'>Search&lt;/button><br>
&lt;/form><br>
&lt;script src='main.js'>&lt;/script><br>
&lt;/body><br>
&lt;/html><br><br>

So taking the google example that even though there is only one search field, this is going to return all the HTML forms contained<br>
therefore when doing something like this you should use indexing, like so:<br><br>

const form = document.forms[0];<br><br>

---------------------------------------------------------------------------------------------------<br><br>

form.action property can be used to set the action attribute of a form, so<br>
it's sent to a different URL to be processed on the server: for example<br><br>

&lt;form action="https://google.com/search" method="get"><br>
&lt;input type="hidden" name="sitesearch" value="http://acme.com" /><br>
&lt;input type="text" name="q" /><br><br>

the submit event, occurring when the form is submitted. Usually this will send<br>
the content of the form to the server to be processed, but we can use JavaScript <br>
to intercept the form before it's sent by adding a submit event listener.<br><br>

const form = document.forms['search']; form.addEventListener ('submit', search, false);<br>
function search() {<br>
alert(' Form Submitted');<br>
}<br><br>

---------------------------------------------------------------------------------------------------<br><br>


you can also use the value property to show the user what was searched for<br><br>

function search(event) {<br>
alert(`You Searched for: ${input.value}`);<br>
event.preventDefault();<br><br>
}<br>

---------------------------------------------------------------------------------------------------<br><br>

common types of form control are:<br><br>

&lt;input&gt; fields, including text, passwords, check boxes, radio buttons, and file uploads<br>
&lt;select&gt; menus for drop-down lists of options<br>
&lt;textarea&gt; elements for longer text entry<br>
&lt;button&gt; elements for submitting and resetting forms<br><br>

---------------------------------------------------------------------------------------------------<br><br>

use for loops to see if each checkbox was checked. Checkbox objects are boolean so true or false<br><br>

---------------------------------------------------------------------------------------------------<br><br>

Hidden fields can be created using input fields with type='hidden'.<br>
file input field can be created using input fields with type='file'. this would allow the user to chose files from there device storage<br><br>

---------------------------------------------------------------------------------------------------<br><br>

use form validating to check that info is entered correctly. Like emails having an @ and a .com, or password having <br>
the correct length or special characteristics.<br><br>

You should validate on the client side and server side. Javascript code is easily bypassed but this does not mean that<br>
you shouldnt validate anyways as this can reduce HTTP requests required.<br><br>

---------------------------------------------------------------------------------------------------<br><br>

<h2>Chapter 12: </h2>
<!-- &lt; < -->
<!-- &gt; > -->
<!-- &emsp; four space tab -->

---------------------------------------------------------------------------------------------------<br><br>

encapsulation: is essentially taking everything and wrapping it up. much like medicine which has been encapsulated or put<br>
into a capsul form. In OOP we make all the logic behind a code inside objects and use methods to implement the code. The world<br>
does not need to see the sausage being made.<br><br>

polymorphism: the same process can be used for different objects<br>
In OOP, this means various objects can share the same method, but also have the<br>
ability to override shared methods with a more specific implementation.<br>
A real-life example of polymorphism, a person at the same time can have different characteristics. Like a man at the same time is a<br>
father, a husband, an employee. So the same person posses different behavior in different situations.<br>

inheritance: like father like son. basically an object can inherit all the properties of a parent object<br>

---------------------------------------------------------------------------------------------------<br><br>

class Classname: creates the class or {} for blocks (class names should be capatalized per convention)<br><br>

---------------------------------------------------------------------------------------------------<br><br>

All objects have a constructor property that returns the constructor function<br>
that created it:<br><br>

blueDice.constructor<br>
&lt;&lt;[Function: Dice]<br><br>

This faciliates creating new objects. The constructor can be used to instantiate a copy of an object<br>
and you don't have to reference the function or class declaration directly.<br><br>

---------------------------------------------------------------------------------------------------<br><br>

Static method is a method defined as a member of an object but is accessible directly from an API object's <br>
constructor, rather than from an object instance created via the constructor.<br><br>

---------------------------------------------------------------------------------------------------<br><br>

It is not possible to overwrite the prototype by assigning it to a new object literal<br>
if class declarations are used:<br><br>

Turtle.prototype = {}<br>
&lt;&lt; {}<br><br>

it looks like the prototype has been reassigned to an empty object literal, but it hasnt...:<br><br>

Turtle.prototype<br>
&lt;&lt; Turtle { attack: [Function], weapon: 'Feet' }<br><br>

you can do this ONLY if the constructor was used, but you have to be careful not to redefine the prototype.<br>

"This is because any instances that have already been created will retain the properties and methods of<br>
the old prototype, but will not receive any of the new properties and methods<br>
that are subsequently added to the redefined prototype."<br>

better to simply use class declarations.<br><br>

prototype can be used to add any new properties and methods after the class<br>
has been declared. this should be used for properties that will be the same for all instances.<br><br>

---------------------------------------------------------------------------------------------------<br><br>

Never use arrays or objects as a default value in prototype. We should always use the [] constructor to avoid this kind of things.<br><br>

---------------------------------------------------------------------------------------------------<br><br>

Take note here.... this is important!

"Create a class declaration that deals with any initialization, shared properties and methods.<br><br>

Any extra methods and properties that need to be augmented to the class declaration <br>
after it's been defined can be added to the prototype. These will be added to all <br>
instances, even those that have already been created.<br><br>

Add any properties or methods that are individual to a particular instance<br>
can be augmented using assignment to that object (a mixin could be used to<br>
add multiple properties at once, as we'll see later).<br><br>

Be careful when overwriting the prototype completely â€• the constructor<br>
class needs to be reset."<br><br>

---------------------------------------------------------------------------------------------------<br><br>

By default, an object's methods are public in JavaScript. or in other words, the are accessible to everyone that<br>
can acces that class instance. This harkens back to scope.<br>

---------------------------------------------------------------------------------------------------<br><br>

Monkey see monkey do :)<br>

Monkey-patching is basically a technique to add or change or even suppress a default behavior without changing the source.<br>
apparently frowned upon in the javascript community, but a great technique none the less.<br>

basically we can reference a function and "hack the function" by changing or modifing the behavior

---------------------------------------------------------------------------------------------------<br><br>

When objects are copied by assignment, they are only copied by reference. Basically the same as your <br>
process tempaltes. When you need to make a change the change will be reflected on all objects(functions and methods)<br>
This change can occur in either the original or the copy. yet all will be affected. so make sure that they are related for sure.<br><br>

This affects our mixin function when we try to copy a property that is an array or<br>
object<br><br>

---------------------------------------------------------------------------------------------------<br><br>

<h2>Chapter 15: </h2>

---------------------------------------------------------------------------------------------------<br><br>

Modular javascript is essentially a way to break apart code into self contained importable mods. Code is then<br>
stored in separate files that can be reused. You can build libraries of useful functions. I see this daily<br>
with SPC where complex formulas are used for things like CPk and PPk. by building this library you can then <br>
import the function needed on demand. Makes your code easier to mainain. The idea is also to keep it as "loosely coupled"<br>
(think train coupling) by keeping it this way you can change out the cars on the train easily without affecting the other cars.<br><br>

It is considered good design to keep code as loosely coupled as possible<br><br>

---------------------------------------------------------------------------------------------------<br><br>
Take note here. this is important!<br><br>

All code in modules is always in strict mode without the need for 'use strict'<br>
and there is no way to opt out of this.  Strict mode makes several changes to normal<br> 
JavaScript semantics: Eliminates some JavaScript silent errors by changing them to throw errors.<br><br>

A module has its own global scope, so any variables created in the top-level<br>
of a module can only be accessed within that module.<br><br>

The value of this in the top level of a module is undefined, rather than the<br>
global object.<br><br>

You can't use HTML-style comments in modules<br><br>

---------------------------------------------------------------------------------------------------<br><br>

example here of how to import modules is not really complicated. Same as you do in python really:<br><br>

first function is created in a file<br>
export const PI = 3.1415926;<br><br>

then in the file you want to use the above mod. you do this:<br>
import { PI } from './pi.js';<br><br>

idea is you could create a library of functions to import into another code<br><br>

Having more than one default export will result in a syntax error. so as an alternative we should use named exports.<br><br>

---------------------------------------------------------------------------------------------------<br><br>
---------------------------------------------------------------------------------------------------<br><br>
---------------------------------------------------------------------------------------------------<br><br>
---------------------------------------------------------------------------------------------------<br><br>
---------------------------------------------------------------------------------------------------<br><br>
---------------------------------------------------------------------------------------------------<br><br>
